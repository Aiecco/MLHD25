# Function to overlay heatmap on an image
import cv2
import numpy as np
from keras import Model
from matplotlib import pyplot as plt


def overlay_heatmap(image, heatmap, alpha=0.5, cmap='jet'):
    """Overlays a heatmap on a grayscale image."""
    # Normalize image for visualization (if not already 0-1 or 0-255)
    image = image - image.min()
    image = image / (image.max() - image.min() + 1e-8)  # Add small epsilon to avoid div by zero

    # Apply colormap to the heatmap
    heatmap = 255 * heatmap  # Scale to 0-255 for colormap
    heatmap = heatmap.astype(np.uint8)
    heatmap_colored = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
    heatmap_colored = cv2.cvtColor(heatmap_colored, cv2.COLOR_BGR2RGB)  # For matplotlib

    # Resize original image to 3 channels for overlay
    if len(image.shape) == 2:  # If grayscale 2D
        image_rgb = cv2.cvtColor((image * 255).astype(np.uint8), cv2.COLOR_GRAY2RGB)
    elif image.shape[-1] == 1:  # If grayscale with 1 channel
        image_rgb = cv2.cvtColor((image[:, :, 0] * 255).astype(np.uint8), cv2.COLOR_GRAY2RGB)
    else:  # Already RGB
        image_rgb = (image * 255).astype(np.uint8)

    # Overlay the heatmap on the original image
    # Ensure heatmap_colored and image_rgb have the same HxW dimensions
    heatmap_resized = cv2.resize(heatmap_colored, (image_rgb.shape[1], image_rgb.shape[0]))

    # Convert image_rgb and heatmap_resized to float before addWeighted
    superimposed_img = cv2.addWeighted(image_rgb.astype(np.float32), 1 - alpha, heatmap_resized.astype(np.float32),
                                       alpha, 0)

    return superimposed_img / 255.0  # Return normalized for pyplot visualization


def visualize_attention_map(model, preprocessed_image_tensor, true_age, std_val, mean_val, save_path=None):
    """
    Visualizes the spatial attention map generated by the model for a given preprocessed image.
    Requires a model with a layer named 'attention_prep' (the output of SpatialAttention).

    Args:
        model (tf.keras.Model): The trained Keras model.
        preprocessed_image_tensor (tf.Tensor): The preprocessed input image tensor (batch_size=1, H, W, C).
        true_age (float): The true age of the patient for the given image.
        std_val (float): Standard deviation used for image denormalization.
        mean_val (float): Mean value used for image denormalization.
        save_path (str, optional): Path to save the plot. If None, displays the plot.
    """
    try:
        # Get the output of the attention_prep layer (which is the attention map)
        attention_layer_output = model.get_layer('attention_prep').output
        attention_model = Model(inputs=model.input, outputs=attention_layer_output)
    except ValueError:
        print("Error: 'attention_prep' layer not found in the model. Cannot visualize attention map.")
        print("Please ensure your SpatialAttention layer's output is named 'attention_prep' or adjust the code.")
        return

    # Get the attention map
    attention_map = attention_model.predict(preprocessed_image_tensor)[0, :, :, 0]  # Remove batch and channel dim

    # Normalize attention map between 0 and 1
    attention_map = (attention_map - attention_map.min()) / (attention_map.max() - attention_map.min() + 1e-8)

    # Upsample attention map to original image size (model's input size)
    img_height, img_width = preprocessed_image_tensor.shape[1:3]
    upsampled_attention_map = cv2.resize(attention_map, (img_width, img_height), interpolation=cv2.INTER_LINEAR)

    # Denormalize the input image for display (assuming it was standardized)
    display_image = (preprocessed_image_tensor[0].numpy() * std_val) + mean_val
    display_image = (display_image - display_image.min()) / (display_image.max() - display_image.min() + 1e-8)

    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(display_image.squeeze(), cmap='gray')
    plt.title(f'Original Image (True Age: {true_age:.2f} months)')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    overlayed_image = overlay_heatmap(display_image.squeeze(), upsampled_attention_map)
    plt.imshow(overlayed_image)
    plt.title('Spatial Attention Map')
    plt.axis('off')

    plt.tight_layout()
    if save_path:
        plt.savefig(save_path, dpi=300)
        plt.close()
    else:
        plt.show()